import numpy as np
import matplotlib.pyplot as plt
import math
import random
from scipy.interpolate import CubicSpline

# ==========================================
# 1. A* Algorithm (최단 거리, 격자 기반)
# ==========================================
class AStarPlanner:
    def __init__(self, ox, oy, resolution, robot_radius):
        self.min_x, self.min_y = min(ox), min(oy)
        self.max_x, self.max_y = max(ox), max(oy)
        self.ox, self.oy = ox, oy
        self.resolution = resolution
        self.robot_radius = robot_radius
        self.x_width = round((self.max_x - self.min_x) / resolution)
        self.y_width = round((self.max_y - self.min_y) / resolution)
        self.obstacle_map = self.calc_obstacle_map(ox, oy)

    class Node:
        def __init__(self, x, y, cost, parent_index):
            self.x = x
            self.y = y
            self.cost = cost
            self.parent_index = parent_index

    def planning(self, sx, sy, gx, gy):
        start_node = self.Node(self.calc_xy_index(sx, self.min_x), self.calc_xy_index(sy, self.min_y), 0.0, -1)
        goal_node = self.Node(self.calc_xy_index(gx, self.min_x), self.calc_xy_index(gy, self.min_y), 0.0, -1)

        open_set, closed_set = dict(), dict()
        open_set[self.calc_grid_index(start_node)] = start_node

        while True:
            if not open_set: break
            c_id = min(open_set, key=lambda o: open_set[o].cost + self.calc_heuristic(open_set[o], goal_node))
            current = open_set[c_id]

            if current.x == goal_node.x and current.y == goal_node.y:
                goal_node.parent_index = current.parent_index
                goal_node.cost = current.cost
                break
            del open_set[c_id]
            closed_set[c_id] = current

            for dx, dy, cost in [(1, 0, 1), (0, 1, 1), (-1, 0, 1), (0, -1, 1), (-1, -1, 1.4), (-1, 1, 1.4), (1, -1, 1.4), (1, 1, 1.4)]:
                node = self.Node(current.x + dx, current.y + dy, current.cost + cost, c_id)
                n_id = self.calc_grid_index(node)
                if n_id in closed_set: continue
                if not self.verify_node(node): continue
                if n_id not in open_set or open_set[n_id].cost > node.cost:
                    open_set[n_id] = node

        rx, ry = self.calc_final_path(goal_node, closed_set)
        return rx, ry

    def calc_heuristic(self, n1, n2): return math.hypot(n1.x - n2.x, n1.y - n2.y)
    def verify_node(self, node):
        px = self.calc_grid_position(node.x, self.min_x)
        py = self.calc_grid_position(node.y, self.min_y)
        if px < self.min_x or py < self.min_y or px >= self.max_x or py >= self.max_y: return False
        if self.obstacle_map[node.x][node.y]: return False
        return True
    def calc_obstacle_map(self, ox, oy):
        pmap = [[False for _ in range(self.y_width)] for _ in range(self.x_width)]
        for ix in range(self.x_width):
            x = self.calc_grid_position(ix, self.min_x)
            for iy in range(self.y_width):
                y = self.calc_grid_position(iy, self.min_y)
                for iox, ioy in zip(ox, oy):
                    d = math.hypot(iox - x, ioy - y)
                    if d <= self.robot_radius:
                        pmap[ix][iy] = True
                        break
        return pmap
    def calc_xy_index(self, position, min_pos): return round((position - min_pos) / self.resolution)
    def calc_grid_position(self, index, min_pos): return index * self.resolution + min_pos
    def calc_grid_index(self, node): return (node.y - 0) * self.x_width + (node.x - 0)
    def calc_final_path(self, goal_node, closed_set):
        rx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], [self.calc_grid_position(goal_node.y, self.min_y)]
        p_index = goal_node.parent_index
        while p_index != -1:
            n = closed_set[p_index]
            rx.append(self.calc_grid_position(n.x, self.min_x))
            ry.append(self.calc_grid_position(n.y, self.min_y))
            p_index = n.parent_index
        return rx, ry

# ==========================================
# 2. RRT Algorithm (랜덤 탐색, 트리 기반)
# ==========================================
class RRT:
    class Node:
        def __init__(self, x, y):
            self.x, self.y = x, y
            self.path_x, self.path_y = [], []
            self.parent = None
    def __init__(self, start, goal, obstacle_list, rand_area, expand_dis=2.0, goal_sample_rate=10, max_iter=1000):
        self.start = self.Node(start[0], start[1])
        self.end = self.Node(goal[0], goal[1])
        self.min_rand, self.max_rand = rand_area
        self.expand_dis = expand_dis
        self.goal_sample_rate = goal_sample_rate
        self.max_iter = max_iter
        self.obstacle_list = obstacle_list
        self.node_list = []

    def planning(self):
        self.node_list = [self.start]
        for i in range(self.max_iter):
            rnd_node = self.get_random_node()
            nearest_ind = self.get_nearest_node_index(self.node_list, rnd_node)
            nearest_node = self.node_list[nearest_ind]
            new_node = self.steer(nearest_node, rnd_node, self.expand_dis)
            if self.check_collision(new_node, self.obstacle_list):
                self.node_list.append(new_node)
            if self.calc_dist_to_goal(self.node_list[-1].x, self.node_list[-1].y) <= self.expand_dis:
                final_node = self.steer(self.node_list[-1], self.end, self.expand_dis)
                if self.check_collision(final_node, self.obstacle_list):
                    return self.generate_final_course(len(self.node_list) - 1)
        return None

    def steer(self, from_node, to_node, extend_length=float("inf")):
        new_node = self.Node(from_node.x, from_node.y)
        d, theta = self.calc_distance_and_angle(new_node, to_node)
        new_node.path_x = [new_node.x]
        new_node.path_y = [new_node.y]
        if extend_length > d: extend_length = d
        new_node.x += extend_length * math.cos(theta)
        new_node.y += extend_length * math.sin(theta)
        new_node.path_x.append(new_node.x)
        new_node.path_y.append(new_node.y)
        new_node.parent = from_node
        return new_node

    def get_random_node(self):
        if random.randint(0, 100) > self.goal_sample_rate:
            rnd = self.Node(random.uniform(self.min_rand, self.max_rand), random.uniform(self.min_rand, self.max_rand))
        else: rnd = self.Node(self.end.x, self.end.y)
        return rnd

    def get_nearest_node_index(self, node_list, rnd_node):
        dlist = [(node.x - rnd_node.x) ** 2 + (node.y - rnd_node.y) ** 2 for node in node_list]
        return dlist.index(min(dlist))

    def check_collision(self, node, obstacle_list):
        for (ox, oy, size) in obstacle_list:
            dx_list = [ox - x for x in node.path_x]
            dy_list = [oy - y for y in node.path_y]
            d_list = [dx * dx + dy * dy for (dx, dy) in zip(dx_list, dy_list)]
            if min(d_list) <= size ** 2: return False
        return True

    def calc_dist_to_goal(self, x, y): return math.hypot(x - self.end.x, y - self.end.y)
    def calc_distance_and_angle(self, from_node, to_node):
        dx, dy = to_node.x - from_node.x, to_node.y - from_node.y
        return math.hypot(dx, dy), math.atan2(dy, dx)
    def generate_final_course(self, goal_ind):
        path = [[self.end.x, self.end.y]]
        node = self.node_list[goal_ind]
        while node.parent is not None:
            path.append([node.x, node.y])
            node = node.parent
        path.append([node.x, node.y])
        return path

# ==========================================
# 3. Spline (경로 스무딩)
# ==========================================
def run_spline_path(x, y):
    # 중복 점 제거 (Spline 오류 방지)
    points = sorted(list(set(zip(x, y))), key=lambda p: x.index(p[0]))
    x, y = zip(*points)
    if(len(x) < 4): return x, y # 점이 너무 적으면 그냥 리턴
    
    cs = CubicSpline(range(len(x)), np.array([x, y]).T)
    t = np.linspace(0, len(x)-1, 100)
    out = cs(t)
    return out[:, 0], out[:, 1]

# ==========================================
# 실행 및 시각화
# ==========================================
def main():
    print("경로 생성 중... 잠시만 기다려주세요.")
    # 미로(장애물) 생성
    ox, oy = [], []
    for i in range(60): ox.append(i); oy.append(0.0)       # 아래 벽
    for i in range(60): ox.append(60.0); oy.append(i)      # 오른쪽 벽
    for i in range(61): ox.append(i); oy.append(60.0)      # 위 벽
    for i in range(61): ox.append(0.0); oy.append(i)       # 왼쪽 벽
    
    # ㄷ자 장애물
    for i in range(40): ox.append(20.0); oy.append(i)      # 중간 벽 1
    for i in range(40): ox.append(40.0); oy.append(60.0 - i) # 중간 벽 2

    sx, sy, gx, gy = 10.0, 10.0, 50.0, 50.0
    robot_radius = 2.0

    plt.figure(figsize=(10, 8))
    plt.plot(ox, oy, ".k", label="Obstacles")
    plt.plot(sx, sy, "^r", markersize=10, label="Start")
    plt.plot(gx, gy, "^b", markersize=10, label="Goal")

    # 1. A* 실행
    a_star = AStarPlanner(ox, oy, resolution=2.0, robot_radius=robot_radius)
    rx, ry = a_star.planning(sx, sy, gx, gy)
    plt.plot(rx, ry, "-r", linewidth=2, label="A* (Shortest)")

    # 2. RRT 실행
    obs_list = [] # RRT용 장애물 변환
    for x, y in zip(ox, oy): obs_list.append((x, y, 1.0))
    rrt = RRT(start=[sx, sy], goal=[gx, gy], rand_area=[0, 60], obstacle_list=obs_list)
    rrt_path = rrt.planning()
    if rrt_path:
        rrt_x = [p[0] for p in rrt_path]
        rrt_y = [p[1] for p in rrt_path]
        plt.plot(rrt_x, rrt_y, "--g", linewidth=1.5, label="RRT (Random)")

    # 3. Spline (A* 기반 스무딩)
    if rx:
        sp_x, sp_y = run_spline_path(rx[::-1], ry[::-1])
        plt.plot(sp_x, sp_y, "-b", linewidth=3, label="Smooth Spline (Drivable)")

    plt .grid(True)
    plt.legend()
    plt.axis("equal")
    plt.title("Path Planning Algorithms Comparison in Maze")
    plt.show()

if __name__ == '__main__':
    main()